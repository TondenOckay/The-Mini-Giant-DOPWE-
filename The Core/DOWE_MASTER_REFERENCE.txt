================================================================================
  DOWE MASTER REFERENCE
  Dynamic Object and World Engine - v2.3
  NWN:EE (NWScript) Production Core
================================================================================
  PURPOSE OF THIS DOCUMENT
  Upload this file at the start of any future session so the AI assistant
  can immediately understand the full architecture, current state, naming
  conventions, NWScript rules, and how to continue development.
================================================================================

================================================================================
  SECTION 1: WHAT THIS SYSTEM IS
================================================================================

DOWE is a complete NWN:EE server core built on NWScript. It replaces the
conventional approach of writing individual, hardcoded heartbeat scripts for
each server feature. Instead, every feature (called a "package") plugs into
a single data-driven hub via a 2DA file. No core code ever changes when a
new feature is added.

The system has been developed iteratively across multiple sessions with an AI
assistant. All core files are production-hardened and have been through
multiple compilation-error debug cycles. The architecture is sound.

KEY DESIGN GOALS:
  - Zero CPU waste on empty areas (areas with no players run nothing)
  - O(1) data lookups at runtime via module-object local variable cache
  - Fully data-driven: 2DAs are the single source of truth for all settings
  - Extensible without touching core: add a row to a 2DA to add a feature
  - Scalable: designed for 200+ areas, 100+ players, 50+ packages

================================================================================
  SECTION 2: FILE INVENTORY - ALL CORE FILES
================================================================================

LIBRARY FILES (no void main, #included by event scripts):
  core_conductor.nss   - System-wide constants and forward declarations only.
                         Every other script includes this. Never has functions.
  core_registry.nss    - Object tracking system. Slot-based registry per area.
  core_grid.nss        - Spatial grid for O(1) proximity lookups.
  core_package.nss     - Package hub engine. Reads core_package.2da.
  core_dispatch.nss    - Active-area registry and heartbeat routing.
  core_ai_gps.nss      - GPS proximity sleep/wake/despawn. Library version.

EVENT SCRIPTS (have void main, wired to module/area events):
  core_onload.nss      - Module OnModuleLoad. Runs all Boot() functions.
  core_enter.nss       - Area OnEnter. Boots lazy area systems.
  core_mhb.nss         - Module OnModuleHeartbeat. Calls DispatchTick().
  core_heartbeat.nss   - Area OnHeartbeat. Failsafe if module HB stalls.
  core_switch.nss      - Area switchboard. Runs once per HB per active area.
  pkg_ai_gps.nss       - GPS package event script. Thin wrapper for GpsTick().

2DA FILES (data, not code):
  core_conductor.nss   - (not a 2DA, but the master constants file)
  core_registry.2da    - Object type definitions (RF_* flags, tags, etc)
  core_grid.2da        - Grid cell size, update interval settings
  core_ai_gps.2da      - GPS distance defaults (sleep dist, despawn dist, etc)
  core_package.2da     - Package registry. One row per subsystem package.

================================================================================
  SECTION 3: THE NWSCRIPT INCLUDE RULE - MOST IMPORTANT THING IN THIS FILE
================================================================================

NWScript does NOT have a linker. It does NOT have #pragma once or #include
guards. It is NOT like C. Understanding this is critical.

  RULE 1: INCLUDES ARE LITERAL PASTE OPERATIONS.
  When NWScript compiles script A which includes script B, it literally
  copies every line of B into A at the point of the #include. There is no
  separate compilation, no object files, no linking step.

  RULE 2: FORWARD DECLARATIONS ARE NOT C-STYLE HEADERS.
  In C, a header file forward-declares a function and the linker finds the
  implementation in a separately compiled .o file. NWScript has no linker.
  A forward declaration in NWScript only tells the compiler "this function
  exists somewhere BELOW me in this same file." The IMPLEMENTATION must also
  be pasted into the same compilation unit. If it is missing, you get:
    ERROR: UNDEFINED IDENTIFIER (FunctionName)

  RULE 3: INCLUDING A FILE TWICE = DUPLICATE FUNCTION ERRORS.
  If script A includes B, and also includes C which also includes B,
  then B's function bodies are pasted into A twice. Every function in B
  becomes a duplicate. You get:
    ERROR: DUPLICATE FUNCTION IMPLEMENTATION (FunctionName)

  RULE 4: CONSTANTS AND FORWARD DECLARATIONS CAN BE DUPLICATED SAFELY.
  "const string FOO = ..." pasted twice is OK.
  "void Foo();" (forward decl with no body) pasted twice is OK.
  "void Foo() { ... }" (full implementation) pasted twice = FATAL ERROR.

  RULE 5: EVERY EVENT SCRIPT IS A COMPLETE SELF-CONTAINED COMPILATION UNIT.
  Each event script (.nss with void main) must include ALL library files
  that contain implementations called anywhere in its entire include chain,
  directly or transitively.

  EXAMPLE OF THE TRANSITIVE PROBLEM:
  core_registry.nss calls PackageRunShutdownScripts() in RegistryShutdown().
  PackageRunShutdownScripts() is implemented in core_package.nss.
  If pkg_ai_gps.nss only includes core_ai_gps (which includes core_registry),
  then PackageRunShutdownScripts has a forward decl but no implementation.
  pkg_ai_gps MUST also include core_package to bring in the implementation.

THE GOLDEN RULE FOR THIS SYSTEM:
  Library files may ONLY #include core_conductor.
  Exception: core_ai_gps includes core_conductor + core_registry + core_grid
  because it uses RF_* constants and Registry functions defined in those files.
  (RF_* are constants, not functions - they cannot be forward-declared.)

================================================================================
  SECTION 4: CURRENT INCLUDE MAP (COMPILE UNIT EXPANSION)
================================================================================

For each event script, this shows EVERY library body that gets pasted in.
"conductor-dup" means core_conductor's constants are pasted again (safe).
All library BODIES appear exactly once in each unit.

  core_onload.nss
    <- core_ai_gps <- core_conductor, core_registry<-conductor-dup, core_grid<-conductor-dup
    <- core_package <- conductor-dup
    <- core_dispatch <- conductor-dup
    void main() [ONCE]

  core_mhb.nss
    <- core_dispatch <- core_conductor
    <- core_package <- conductor-dup
    void main() [ONCE]

  core_enter.nss
    <- core_registry <- core_conductor
    <- core_grid <- conductor-dup
    <- core_package <- conductor-dup
    <- core_conductor (direct, dup-OK)
    void main() [ONCE]

  core_switch.nss
    <- core_conductor
    <- core_registry <- conductor-dup
    <- core_package <- conductor-dup
    <- core_grid <- conductor-dup
    void main() [ONCE]

  core_heartbeat.nss
    <- core_registry <- core_conductor
    <- core_conductor (direct, dup-OK)
    void main() [ONCE]
    NOTE: Only calls RegistryPCCount (in registry) + ExecuteScript strings. Clean.

  pkg_ai_gps.nss
    <- core_ai_gps <- core_conductor, core_registry<-conductor-dup, core_grid<-conductor-dup
    <- core_package <- conductor-dup
    void main() [ONCE]

================================================================================
  SECTION 5: COMPILE ORDER
================================================================================

In the NWN Toolset, compile scripts in this exact order. Each depends on
the ones above it being compiled first so the toolset can resolve includes.

  1.  core_conductor    (no dependencies - pure constants + forward decls)
  2.  core_registry     (includes core_conductor only)
  3.  core_grid         (includes core_conductor only)
  4.  core_package      (includes core_conductor only)
  5.  core_dispatch     (includes core_conductor only)
  6.  core_ai_gps       (includes core_conductor, core_registry, core_grid)
  7.  pkg_ai_gps        (includes core_ai_gps, core_package)
  8.  core_switch       (includes core_conductor, core_registry, core_package, core_grid)
  9.  core_enter        (includes core_registry, core_grid, core_package, core_conductor)
  10. core_heartbeat    (includes core_registry, core_conductor)
  11. core_mhb          (includes core_dispatch, core_package)
  12. core_onload       (includes core_ai_gps, core_package, core_dispatch)

================================================================================
  SECTION 6: MODULE WIRING (TOOLSET SETTINGS)
================================================================================

In Module Properties -> Events, wire these scripts:

  OnModuleLoad      -> core_onload
  OnModuleHeartbeat -> core_mhb

In every Area Properties -> Events, wire:

  OnEnter           -> core_enter
  OnHeartbeat       -> core_heartbeat

Every area needs both. The area heartbeat is a failsafe only - normal ticking
comes from the module heartbeat through core_mhb -> DispatchTick -> core_switch.

================================================================================
  SECTION 7: HOW THE RUNTIME WORKS - THE FULL TICK CYCLE
================================================================================

BOOT SEQUENCE (OnModuleLoad -> core_onload):
  1. RegistryBoot()     - Reads core_registry.2da. Caches object type
                          definitions to module locals. Sets up RF_* composite
                          flags. Never reads the 2DA again.
  2. GridBoot()         - Reads core_grid.2da. Caches cell size, update interval.
  3. GpsBoot()          - Reads core_ai_gps.2da. Caches sleep/despawn distances.
  4. PackageBoot()      - Reads core_package.2da. Caches ALL package row data
                          to module locals (PKG_[N]_SCRIPT, PKG_[N]_PHASE, etc).
  5. PackageCreateTable() - Ensures the SQL override table exists.
  6. DispatchBoot()     - Initializes active area counter to zero.

LAZY AREA BOOT (OnEnter -> core_enter, first PC to enter):
  1. RegistryAutoRegister() - Registers the entering PC. Calls RegistryActivateArea
                              internally when PC count crosses 0->1.
                              RegistryActivateArea adds this area to the active
                              area list on the module object (MG_ACTIVE_[N]).
  2. GridInitArea()     - Computes grid cell dimensions for this area.
  3. RegistryInitArea() - Cold-scans the area for pre-placed objects and
                          registers them all into the slot system.
  4. PackageLoad()      - Reads SQL area overrides (one query), builds per-area
                          JSON blob with mutable package state. Stored as a
                          local string on the area object.
  5. PackageRunBootScripts() - Fires each package's BOOT_SCRIPT if it has one.

EACH HEARTBEAT (OnModuleHeartbeat -> core_mhb, every ~6 seconds):
  DispatchTick():
    1. Increment global tick counter (MG_TICK on module object).
    2. Call RecordScheduledTick() - stamps when dispatch fired for load drift.
    3. Read MG_ACTIVE_CNT from module object.
    4. If zero active areas, return immediately (zero CPU on empty server).
    5. Calculate per-area stagger (4.5 seconds spread across all active areas).
    6. DelayCommand(stagger, ExecuteScript("core_switch", oArea)) for each area.

PER ACTIVE AREA (core_switch, runs once per heartbeat per area with players):
  Phase 0: Maintenance (ghost cleanup, expiry cull, despawn checks) - staggered
  Phase 1: MeasureLoadDrift() - checks if DelayCommands are running late
  Phase 2: PackageUpdatePauseStates() - pauses packages if server load is high
  Phase 3: Package dispatch loop:
           - Reads PKG_ROW_CNT from module object
           - For each row: PackageIsRunnable() gates the dispatch
           - If runnable: PackageRecordRun(), then DelayCommand(phase, ExecuteScript(script, area))
           - The script name comes from the module cache (PKG_[N]_SCRIPT)
           - This is HOW the 2DA row drives what runs: PackageBoot() read the
             SCRIPT column and cached it; now core_switch reads that cache.
  Phase 4: GridTickUpdate() - updates creature positions in grid cells

AREA SHUTDOWN (last PC leaves -> RegistryDeactivateArea -> delayed RegistryShutdown):
  1. PackageRunShutdownScripts() - fires each package's SHUTDOWN_SCRIPT
  2. Destroy all registered cullable objects
  3. Clear area effects
  4. Wipe all slot data from area locals
  5. PackageUnload() - delete the per-area JSON
  6. GridShutdownArea() - clear grid data
  7. RegistryDeactivateArea() - remove from active area list
  Server cost drops to zero for this area until a PC enters again.

================================================================================
  SECTION 8: HOW THE PACKAGE 2DA DRIVES SCRIPT EXECUTION
================================================================================

ANSWERING YOUR DIRECT QUESTION: "Does the package.2da read the actual
script/package name on the row - is that how it knows what script to call?"

YES. Here is the exact chain:

  core_package.2da has a column called SCRIPT.
  Row 0: PACKAGE=ai_gps, SCRIPT=pkg_ai_gps, PHASE=0.5, INTERVAL=1, ...

  At server boot, PackageBoot() reads every row of the 2DA and stores:
    SetLocalString(oMod, "PKG_0_SCRIPT", "pkg_ai_gps")
    SetLocalString(oMod, "PKG_0_NAME",   "ai_gps")
    SetLocalFloat(oMod,  "PKG_0_PHAS",   0.5)
    ... etc for every column

  At runtime in core_switch, the dispatch loop does:
    string sScript = GetLocalString(oMod, "PKG_0_SCRIPT")
    // sScript is now "pkg_ai_gps"
    DelayCommand(fPhase, ExecuteScript(sScript, oArea))
    // ExecuteScript("pkg_ai_gps", oArea) fires the GPS tick

  The 2DA is never read again after PackageBoot(). Everything is in module
  locals for O(1) access. Adding a new package = add a row to the 2DA.
  The system reads it on next server boot. No code changes ever.

KEY COLUMNS IN core_package.2da:
  PACKAGE         - Unique string ID for this package (e.g. "ai_gps")
  ENABLED         - 1 to run, 0 to disable globally
  PRIORITY        - Lower number runs first (1=highest). Used for ordering.
  SCRIPT          - The .nss file executed each tick (no extension)
  BOOT_SCRIPT     - Script to run when an area boots (or **** for none)
  SHUTDOWN_SCRIPT - Script to run when an area shuts down (or **** for none)
  INTERVAL        - Run every N ticks (1 = every tick, 2 = every other tick)
  MIN_PLAYERS     - Don't run unless this many PCs are in the area (0 = always)
  PAUSE_THRESHOLD - Pause this package if load score exceeds this % (0 = never)
  AREA_OVERRIDE   - 1 if DMs can enable/disable this per-area via SQL
  PHASE           - DelayCommand offset in seconds within the tick window

================================================================================
  SECTION 9: HOW TO ADD A NEW PACKAGE
================================================================================

A package is any server feature that needs to run on a heartbeat per area.
Examples: encounter spawning, NPC live AI, weather, resource regeneration,
shop restocking, faction reputation decay, etc.

STEP 1: Write your tick script (e.g. pkg_myfeature.nss)
  #include "core_conductor"     // Always
  #include "core_registry"      // If you use registry functions
  #include "core_package"       // If you call any Package* functions
  #include "core_grid"          // If you use grid functions

  void main()
  {
      object oArea = OBJECT_SELF;
      // Your per-area per-tick logic here.
      // You have access to the full registry (all creatures, PCs, items in area).
      // You have grid-accelerated proximity functions.
      // RegistryFirst/RegistryNext iterates objects by type flag.
  }

  NOTE: If your tick script is ALSO included as a library by another script
  (like core_ai_gps is included by core_onload), you must split it:
    pkg_myfeature_lib.nss  - library (no main), all functions
    pkg_myfeature.nss      - thin wrapper (has main, includes library)

STEP 2: Optionally write boot and shutdown scripts
  pkg_myfeature_boot.nss  - runs once when an area goes live
  pkg_myfeature_shut.nss  - runs when the last PC leaves an area

STEP 3: Add one row to core_package.2da
  ROW  PACKAGE      ENBL  PRI  SCRIPT           BOOT_SCRIPT          SHUTDOWN_SCRIPT      IVRL  MNPC  PSAT  AOVR  PHASE
  1    myfeature    1     5    pkg_myfeature    pkg_myfeature_boot   pkg_myfeature_shut   1     1     75    1     1.0

  That is literally all. Server restart required.
  The core will automatically call your script every tick for every active area.
  On area boot it will call pkg_myfeature_boot.
  On area shutdown it will call pkg_myfeature_shut.

STEP 4: Compile (in order)
  Compile your new scripts after the core libraries they depend on.

================================================================================
  SECTION 10: PACKAGE HUB PATTERN (SUB-SYSTEMS WITHIN A PACKAGE)
================================================================================

Some packages are complex enough to have their own sub-systems. For example,
an encounter system might have: spawn logic, patrol logic, loot logic, and
faction logic. These are all part of the "encounter" package but are separate
enough to deserve their own data-driven configuration.

This is where the HUB PATTERN comes in.

THE CONCEPT:
  A hub script is the tick script for a package. Instead of doing all the
  work itself, it reads its own 2DA (e.g. enc_hub.2da) and dispatches to
  sub-scripts just like core_package dispatches to packages.

  core_package.2da  ->  pkg_encounters (hub script)
                            |
                            +->  enc_hub.2da  ->  pkg_enc_spawn
                            |                 ->  pkg_enc_patrol
                            |                 ->  pkg_enc_loot
                            +-> (manages its own JSON state per area)

WHY USE JSON FOR SUB-SYSTEM STATE:
  core_package.nss uses a JSON array indexed by 2DA row for per-area mutable
  state. Hub scripts follow the same pattern for their own sub-systems.

  The encounter hub needs to track per-area state for each sub-system:
    - Is this sub-system paused for this area?
    - How many times has it run in this area?
    - What was the last tick it ran?
    - Are there any per-area overrides to its settings?

  JSON stored as a local string on the area object is the correct tool.
  It is compact, readable, and requires no additional NWN:EE infrastructure.

HOW TO BUILD A HUB SCRIPT AND ITS 2DA:

  STEP 1: Create your hub 2DA (e.g. enc_hub.2da)
    This 2DA mirrors the structure of core_package.2da but is owned by your
    package. Columns you probably want:
      ROW  SYSTEM      ENBL  PRI  SCRIPT           INTERVAL  PHASE  DESCRIPTION
      0    spawn        1     1    pkg_enc_spawn     1         0.1    Spawn encounters from tables
      1    patrol       1     2    pkg_enc_patrol    1         0.3    Move patrols along waypoints
      2    loot         1     3    pkg_enc_loot      2         0.5    Refresh loot tables
      3    faction      1     4    pkg_enc_faction   5         0.7    Decay faction relationships

  STEP 2: Create a boot function for the hub (enc_boot.nss)
    This runs once when an area goes live. It reads enc_hub.2da and caches
    the sub-system definitions to module locals (just like PackageBoot()).
    It also initializes the per-area JSON for this area.

    Example boot:
      void EncBoot()
      {
          object oMod = GetModule();
          if (GetLocalInt(oMod, "ENC_HUB_BOOTED")) return;
          SetLocalInt(oMod, "ENC_HUB_BOOTED", 1);

          int nRows = Get2DARowCount("enc_hub");
          SetLocalInt(oMod, "ENC_ROW_CNT", nRows);

          int i;
          for (i = 0; i < nRows; i++)
          {
              string sN = "ENC_" + IntToString(i);
              SetLocalString(oMod, sN + "_SCRP", Get2DAString("enc_hub", "SCRIPT",   i));
              SetLocalInt(oMod,    sN + "_ENBL", StringToInt(Get2DAString("enc_hub", "ENBL",     i)));
              SetLocalInt(oMod,    sN + "_IVRL", StringToInt(Get2DAString("enc_hub", "INTERVAL", i)));
              SetLocalFloat(oMod,  sN + "_PHAS", StringToFloat(Get2DAString("enc_hub", "PHASE",  i)));
          }
      }

    Call EncBoot() from your area boot script (pkg_enc_areaboot.nss).
    Register pkg_enc_areaboot as the BOOT_SCRIPT in core_package.2da.

  STEP 3: Create the per-area JSON for the hub (in the area boot script)
    json jArr = JsonArray();
    int i;
    for (i = 0; i < nRows; i++)
    {
        json jSys = JsonObject();
        jSys = JsonObjectSet(jSys, "paused",    JsonInt(0));
        jSys = JsonObjectSet(jSys, "last_tick", JsonInt(0));
        jSys = JsonObjectSet(jSys, "run_count", JsonInt(0));
        jArr = JsonArrayInsert(jArr, jSys);
    }
    SetLocalString(oArea, "ENC_HUB_JSON", JsonDump(jArr));

  STEP 4: The hub tick script (pkg_encounters.nss)
    This reads the module cache and per-area JSON, then dispatches sub-scripts.
    It is a miniature version of core_switch.nss for the encounter domain.

    void main()
    {
        object oArea = OBJECT_SELF;
        object oMod  = GetModule();
        int nTick    = GetLocalInt(oMod, MG_TICK);
        int nRows    = GetLocalInt(oMod, "ENC_ROW_CNT");

        string sJson = GetLocalString(oArea, "ENC_HUB_JSON");
        if (sJson == "") return;  // Area not booted yet

        json jArr = JsonParse(sJson);
        int bChanged = FALSE;

        int i;
        for (i = 0; i < nRows; i++)
        {
            string sN = "ENC_" + IntToString(i);
            if (!GetLocalInt(oMod, sN + "_ENBL")) continue;

            string sScript = GetLocalString(oMod, sN + "_SCRP");
            if (sScript == "") continue;

            int    nIvrl    = GetLocalInt(oMod, sN + "_IVRL");
            float  fPhase   = GetLocalFloat(oMod, sN + "_PHAS");

            json jSys    = JsonArrayGet(jArr, i);
            int  nLast   = JsonGetInt(JsonObjectGet(jSys, "last_tick"));
            int  nPaused = JsonGetInt(JsonObjectGet(jSys, "paused"));

            if (nPaused) continue;
            if (nIvrl > 1 && (nTick - nLast) < nIvrl) continue;

            // Update last_tick before dispatching
            jSys = JsonObjectSet(jSys, "last_tick", JsonInt(nTick));
            int nCnt = JsonGetInt(JsonObjectGet(jSys, "run_count")) + 1;
            jSys = JsonObjectSet(jSys, "run_count", JsonInt(nCnt));
            jArr = JsonArraySet(jArr, i, jSys);
            bChanged = TRUE;

            DelayCommand(fPhase, ExecuteScript(sScript, oArea));
        }

        if (bChanged)
            SetLocalString(oArea, "ENC_HUB_JSON", JsonDump(jArr));
    }

  STEP 5: Each sub-script (e.g. pkg_enc_spawn.nss) gets OBJECT_SELF = the area.
    It does its specific job and returns. No knowledge of the hub needed.

WHY NOT JUST ADD MORE ROWS TO core_package.2da?
  You could. For simple packages this is fine. But for a feature like encounters
  that has 10-15 interconnected sub-systems sharing state (e.g. the spawn system
  needs to know what the patrol system placed), a dedicated hub with its own 2DA
  and JSON gives you:
    - Shared state accessible to all sub-scripts via the area's hub JSON
    - Finer-grained control (pause just the spawn sub-system, not the whole enc package)
    - Cleaner 2DA organization (enc_hub.2da has only encounter rows, not everything)
    - A natural place to put encounter-specific utility functions (one include)

================================================================================
  SECTION 11: REGISTRY SYSTEM - HOW OBJECTS ARE TRACKED
================================================================================

Every object in an active area is tracked in the registry. Each area has a
slot-based list stored as local variables on the area object.

SLOT VARIABLES (per slot N, prefix RS_PFX + N + "_"):
  RSF_OBJ      - the object reference
  RSF_FLAG     - type bitmask (RF_PLAYER, RF_NPC, RF_ITEM, etc)
  RSF_TAG      - tag string cached for fast lookup
  RSF_EXPIRE   - tick at which this slot expires (0 = never)
  RSF_GRIDCELL - current grid cell index
  RSF_ROW      - which registry.2da row defines this object type
  RSF_CDKEY    - PC CD key (players only)
  RSF_OWNER    - slot index of owning creature (associates)

FREELIST: The registry uses a freelist for O(1) slot allocation. When a slot
is freed, it is pushed to the freelist. New registrations pop from the
freelist first before extending the array. Slots start at index 1.

TYPE FLAGS (RF_*): Defined in core_registry.2da. Each object type has a
bitmask flag. RF_ALL_CREATURES is a composite flag covering all creature types.
core_ai_gps uses RF_PLAYER to iterate only PCs and RF_ALL_CREATURES to check
creatures in grid cells.

ITERATION PATTERN:
  string sTok = RegistryToken();
  object oPC  = RegistryFirst(oArea, RF_PLAYER, sTok);
  while (GetIsObjectValid(oPC))
  {
      // do work with oPC
      oPC = RegistryNext(oArea, sTok);
  }
  Tokens are small integers stored on the module object, allowing multiple
  concurrent iterations without a stack.

================================================================================
  SECTION 12: TWO-LAYER CACHE DESIGN
================================================================================

LAYER 1 - MODULE CACHE (static, read once at boot):
  PackageBoot() reads core_package.2da ONCE and stores every field as local
  variables on the module object:
    PKG_0_SCRIPT, PKG_0_NAME, PKG_0_PHAS, PKG_0_IVRL, PKG_0_ENBL, etc.
    PKG_ROW_CNT = total rows
  These are NEVER updated at runtime. They are O(1) reads by integer key.
  Module locals do not decay. They survive forever until server restart.

LAYER 2 - PER-AREA JSON (mutable, one blob per area):
  PackageLoad() creates a JSON array stored as a local string on the area object.
  One JSON object per package row, containing:
    "p"  = paused flag (set by load hysteresis)
    "lt" = last_tick_ran (for interval enforcement)
    "rc" = run_count (diagnostics)
    "eo" = per-area enabled override (-1 = use global)
    "io" = per-area interval override (0 = use global)
    "po" = per-area pause threshold override (0 = use global)

  PackageSetState() and PackageGetState() are the only functions that touch
  this JSON at runtime. The JSON is wiped by PackageUnload() on area shutdown.

WHY TWO LAYERS?
  Module cache: immutable, O(1), always available, zero serialization cost.
  Area JSON: mutable per-area state, compact, survives area ticks, easy to
  override per-area without touching module data.

================================================================================
  SECTION 13: SPATIAL GRID SYSTEM
================================================================================

The grid divides each area into cells (default 40m x 40m from core_grid.2da).
Each object in the registry has a grid cell index stored in RSF_GRIDCELL.

PURPOSE: Eliminate full-area scans for proximity checks. Instead of checking
all N creatures against all M players (O(N*M)), the GPS system only checks
creatures in the neighborhood cells of each player (O(k) where k is small).

GridGetNeighborCells() returns the current player's cell plus its 8 neighbors
and stores them in module locals (GRD_NC_0 through GRD_NC_8). The GPS tick
reads these to build its work list.

GridCellGetCount() / GridCellGetSlot() iterate the objects in a specific cell.

GridTickUpdate() is called by core_switch every N ticks (from 2DA setting) to
update all objects' grid cell assignments based on current position.

================================================================================
  SECTION 14: LOAD MEASUREMENT AND PACKAGE THROTTLING
================================================================================

NWScript cannot measure CPU directly. The system estimates server load by
measuring DelayCommand drift:
  - RecordScheduledTick() stamps the tick number when core_switch was scheduled.
  - MeasureLoadDrift() in core_switch reads the current tick and compares.
  - If the tick advanced by 1 while waiting: light load (~35%).
  - If it advanced by 2+: heavy load (~65-90%).

UpdateLoadScore() maintains a rolling 5-sample average (PKG_LOAD_HISTORY = 5).

PackageUpdatePauseStates() uses hysteresis:
  - Package pauses when load >= PAUSE_THRESHOLD.
  - Package resumes when load falls to (PAUSE_THRESHOLD - PKG_HYSTERESIS).
  - Default hysteresis is 10 (defined as PKG_HYSTERESIS in core_package.nss).
  This prevents rapid on/off cycling when load sits near the threshold.

================================================================================
  SECTION 15: CURRENT STATUS AND WHAT WAS LAST FIXED
================================================================================

All compilation errors as of the most recent session have been resolved.

ERRORS FIXED (chronological):
  1. core_registry: NOT ALL CONTROL PATHS RETURN A VALUE in RegistryClassify()
     Fix: Replaced switch statement with explicit if chains, each with return.

  2. core_package: DECLARATION DOES NOT MATCH PARAMETERS for SqlStep()
     Fix: PackageCreateTable() now stores sqlquery q, then calls SqlStep(q).

  3. core_switch: DelayCommand with non-void return type (RegistryCheckDespawn)
     Fix: Added RegistryCheckDespawn_Void() wrapper. Reordered so implementation
     appears before the wrapper in core_registry.nss (NWScript is top-down).

  4. Duplicate main() / Duplicate functions caused by core_ai_gps having
     both void main() and being #included by core_onload.
     Fix: Removed main() from core_ai_gps. Made it a pure library.
     Created pkg_ai_gps.nss as the thin event wrapper with void main().
     Updated core_package.2da SCRIPT column to point to pkg_ai_gps.

  5. DUPLICATE FUNCTION errors from core_dispatch including core_package,
     while other scripts include both core_dispatch and core_package.
     Fix: Removed core_package include from core_dispatch. Added
     RecordScheduledTick forward declaration to core_conductor. All event
     scripts that need the implementation include core_package directly.

  6. UNDEFINED IDENTIFIER (PackageRunShutdownScripts) in pkg_ai_gps
     UNDEFINED IDENTIFIER (RecordScheduledTick) in core_mhb
     Root cause: Forward declarations in core_conductor are NOT C-style headers.
     The implementation must be in the compilation unit.
     Fix: pkg_ai_gps now includes core_package. core_mhb now includes core_package.

  7. core_const renamed to core_conductor.
     core_hb renamed to core_heartbeat.
     All #include references updated across all files.

  8. RegistryCheckDespawn_Void called RegistryCheckDespawn before it was defined.
     Fix: Moved RegistryCheckDespawn implementation above its void wrapper in
     core_registry.nss. Added RegistryCheckDespawn forward decl to core_conductor.

CURRENT STATE: All 13 files should compile cleanly in the order listed in
Section 5. Ready for in-game testing.

FILES THAT NO LONGER EXIST (DELETE FROM MODULE IF PRESENT):
  core_const.nss     -> replaced by core_conductor.nss
  core_hb.nss        -> replaced by core_heartbeat.nss
  core_shutdown.nss  -> old file, functionality in core_registry.nss
  core_spawn.nss     -> old file, not part of current architecture
  core_modload.nss   -> old file, replaced by core_onload.nss
  mg_*.nss           -> old files from previous system version

================================================================================
  SECTION 16: FORWARD DECLARATIONS IN core_conductor.nss - COMPLETE LIST
================================================================================

These must be kept in sync whenever a new public function is added to any
library. The forward decl allows cross-library calls within a compilation unit
WHERE THE IMPLEMENTATION IS ALSO PRESENT (via includes).

  // core_registry.nss
  void RegistryBoot();
  void RegistryActivateArea(object oArea);
  void RegistryDeactivateArea(object oArea);
  int  RegistryPCCount(object oArea);
  void RegistryInitArea(object oArea);
  void RegistryClean(object oArea);
  int  RegistryCull(object oArea);
  void RegistryCull_Void(object oArea);
  int  RegistryCheckDespawn(object oArea);
  void RegistryCheckDespawn_Void(object oArea);
  void RegistryShutdown(object oArea);
  int  RegistryAutoRegister(object oObj, object oArea, int bFromEnter, int nOwnerSlot = 0);

  // core_package.nss
  void PackageBoot();
  void PackageCreateTable();
  void PackageLoad(object oArea);
  void PackageUnload(object oArea);
  void PackageRunBootScripts(object oArea);
  void PackageRunShutdownScripts(object oArea);
  void RecordScheduledTick(object oMod, int nTick);

  // core_grid.nss
  void GridBoot();
  void GridInitArea(object oArea);
  void GridShutdownArea(object oArea);
  void GridTickUpdate(object oArea);

  // core_ai_gps.nss
  void GpsBoot();
  void GpsTick(object oArea);

  // core_dispatch.nss
  void DispatchBoot();
  void DispatchTick();
  void DispatchAreaActivate(object oArea);
  void DispatchAreaDeactivate(object oArea);

================================================================================
  SECTION 17: CONSTANTS REFERENCE
================================================================================

From core_conductor.nss:

  MG_DEBUG          = "MG_DEBUG"         // Master debug toggle (SetLocalInt on module)
  MG_DEBUG_REG      = "MG_DEBUG_REG"     // Registry debug
  MG_DEBUG_PKG      = "MG_DEBUG_PKG"     // Package debug
  MG_DEBUG_GRID     = "MG_DEBUG_GRID"    // Grid debug
  MG_DEBUG_DISP     = "MG_DEBUG_DISP"    // Dispatch debug
  MG_DEBUG_GPS      = "MG_DEBUG_GPS"     // GPS debug

  MG_TICK           = "MG_TICK"          // Current tick counter (int on module)
  MG_LAST_TICK      = "MG_LAST_TICK"     // Last dispatch tick
  MG_TICK_RESET     = 10000              // Tick wraps at this value

  MG_SW_GHOST_INTERVAL = 10             // Ticks between ghost cleanup runs
  MG_SW_CULL_INTERVAL  = 5             // Ticks between expiry cull runs
  MG_SW_DESP_INTERVAL  = 3             // Ticks between despawn check runs

  MG_FAILSAFE_BEATS = 3                 // Missed beats before area failsafe fires

  MG_SQL_DB         = "dowe_server"     // External SQLite database name

================================================================================
  END OF DOWE MASTER REFERENCE
================================================================================

================================================================================
  SECTION 18: SECURITY & DEBUG SYSTEM (Added Session 3)
================================================================================

--------------------------------------------------------------------------------
  18.1 OVERVIEW - THE RBAC WRAPPER ARCHITECTURE
--------------------------------------------------------------------------------

The DOWE security and debug system uses a "wrapper" model:

  THE AUTHORITY (2DA): core_admin.2da defines who has access and what role.
  THE LIBRARY (NWScript): core_admin.nss caches the 2DA and handles commands.
  THE WRAPPER (core_switch + ai_hub): Before each script dispatch, the engine
    checks whether this package has debug turned on and logs accordingly.
  THE LEAF (logic scripts): Individual package scripts are pure logic. They
    contain zero security checks and zero debug clutter.

KEY PRINCIPLE: Auth is only needed for MANUAL DM console commands. Automatic
tick-based dispatch runs regardless of admin role. This is correct behavior -
you don't want a server restart required to turn encounters back on.

--------------------------------------------------------------------------------
  18.2 core_admin.2da - THE AUTHORITY TABLE
--------------------------------------------------------------------------------

File: core_admin.2da
Cached by: AdminBoot() in core_admin.nss

COLUMNS:
  LABEL      Human-readable name. Written to server log on auth events.
  CD_KEY     The player's NWN public CD key (8 chars from server console).
             Set to **** to disable the row without losing data.
  PASSWORD   Plain text, no spaces, no double-quotes. Hidden from public chat.
  ACTIVE     1=load this row, 0=skip. Faster than role=0 for disabling rows.
  ROLE       10=MASTER, 5=BUILDER, 1=MOD, 0=REVOKED.
  DESCRIPTION Human-readable note.

ROLE LEVELS:
  10 = MASTER   All commands: reload everything, force area shutdown, lockdown.
   5 = BUILDER  Reload 2DAs, toggle packages on/off globally, all debug.
   1 = MOD      View debug traces and read status only.
   0 = REVOKED  Row present but access denied. Use instead of deleting rows.

SETUP:
  1. Find CD keys from your server console or player .bic files.
  2. Replace ******** with actual CD keys.
  3. Set ACTIVE=1 for rows you want to activate.
  4. Change all passwords from "ChangeMe..." before going live.
  5. Import into the module via toolset (or ERF import).
  6. At server start, AdminBoot() caches all ACTIVE rows to module locals.

HOT-RELOAD (no server restart needed):
  Edit core_admin.2da on disk, then type in-game:
    /*reload admin "currentmasterpassword"
  This resets the boot flag and re-reads the 2DA immediately.
  Team member leaves? Change their password or set ACTIVE=0, reload admin.

--------------------------------------------------------------------------------
  18.3 core_admin.nss - THE SECURITY LIBRARY
--------------------------------------------------------------------------------

File: core_admin.nss
Type: LIBRARY (no void main, #include "core_conductor" only)
Called by: Your MUD/chat handler script

FUNCTIONS:
  AdminBoot()                  - Reads core_admin.2da once. Call from OnLoad.
  AdminGetRole(oPC, sPass)     - Returns role level or 0 if auth fails.
  AdminParseCommand(sRawMsg)   - Extracts command from "/*cmd \"pass\"" string.
  AdminParsePassword(sRawMsg)  - Extracts password from between double-quotes.
  AdminSetDebugAll(bOn)        - Toggles ALL debug flags on module.
  AdminSetDebugGroup(sGrp,bOn) - Toggles a named group (ai, gps, enc, etc).
  AdminHandleCommand(oPC, sMsg)- Full command dispatcher. Call this from MUD.

INTEGRATION WITH YOUR MUD CHAT SCRIPT:
  Your MUD script handles OnPlayerChat. Add at the very top of void main():

    object oPC  = GetPCChatSpeaker();
    string sMsg = GetPCChatMessage();

    if (GetStringLeft(sMsg, 2) == "/*")
    {
        SetPCChatMessage("");         // Hide password from public chat FIRST
        AdminHandleCommand(oPC, sMsg);
        return;                       // Don't fall into MUD logic
    }
    // ... your existing MUD code continues here ...

  Your MUD script MUST include these libraries (in this order to avoid duplicates):
    #include "core_ai_gps"      // brings conductor, registry, grid
    #include "core_package"     // brings package functions
    #include "core_admin"       // brings admin functions (conductor dup = OK)

NWSCRIPT INCLUDE WARNING:
  core_admin.nss only includes core_conductor. AdminHandleCommand calls functions
  from core_registry (RegistryBoot, RegistryShutdown), core_package (PackageBoot,
  PackageGetRow), core_ai_gps (GpsBoot), and ai_hub.nss (AiHubBoot). Those
  implementations must be present in the MUD script's compilation unit.
  See Section 3 of this document for include chain rules.

--------------------------------------------------------------------------------
  18.4 COMMAND REFERENCE - COMPLETE LIST
--------------------------------------------------------------------------------

All commands use the format:  /*command "password"
Password must be in double-quotes. The raw message is hidden immediately.

ROLE 1+ (MODERATOR):
  /*debug on "pass"           Enable ALL debug flags (master + all groups)
  /*debug off "pass"          Disable ALL debug flags
  /*debug ai on "pass"        Enable AI hub + all AI sub-system debug
  /*debug ai off "pass"       Disable AI debug
  /*debug gps on "pass"       Enable GPS proximity debug
  /*debug gps off "pass"      Disable GPS debug
  /*debug enc on "pass"       Enable encounter debug
  /*debug enc off "pass"      Disable encounter debug
  /*status "pass"             Show active areas, tick, package count, debug state

ROLE 5+ (BUILDER):
  /*reload "pass"             Reload ALL 2DA caches (admin, registry, gps, pkg, ai_hub)
  /*reload admin "pass"       Reload admin 2DA only (use after adding/changing team)
  /*reload registry "pass"    Reload registry 2DA (object types)
  /*reload gps "pass"         Reload GPS 2DA (despawn distances)
  /*pkg off [name] "pass"     Disable package globally (e.g. /*pkg off ai_hub "pass")
  /*pkg on [name] "pass"      Enable package globally

ROLE 10+ (MASTER):
  /*lockdown "pass"           Toggle console lockdown (disables all console commands)
  /*shutdown area "pass"      Force the DM's current area to shut down

--------------------------------------------------------------------------------
  18.5 DEBUG SYSTEM - HOW IT WORKS
--------------------------------------------------------------------------------

The debug system is hierarchical. Three levels:

  LEVEL 1 - MASTER SWITCH:
    MG_DEBUG on the module object. If this is 0, ALL debug is silenced.
    Setting it to 0 is the fastest way to stop all debug output.

  LEVEL 2 - PACKAGE/SUB-SYSTEM FLAG:
    Each package row in core_package.2da has a DEBUG_VAR column.
    Each hub sub-system row in ai_hub.2da has a DEBUG_VAR column.
    Example: ai_gps package has DEBUG_VAR = "MG_DEBUG_GPS".
    core_switch checks GetLocalInt(oMod, "MG_DEBUG_GPS") before logging.
    Only fires if BOTH master debug AND the package flag are on.

  LEVEL 3 - INDIVIDUAL FLAGS:
    You can add finer-grained flags inside your own package scripts.
    Same pattern: check GetLocalInt(oMod, MG_DEBUG) first, then check
    your specific flag.

HOW core_switch WRAPS EACH DISPATCH (added to Phase 3):
    if (GetLocalInt(oMod, MG_DEBUG))
    {
        string sDbgVar = GetLocalString(oMod, PKG_PFX + row + PKGC_DBG);
        if (sDbgVar != "" && GetLocalInt(oMod, sDbgVar))
        {
            SendMessageToAllDMs("[DEBUG] Dispatch: " + pkgname + " Area=... T=... Load=...");
        }
    }

PRODUCTION COST: Two GetLocalInt calls that evaluate to FALSE instantly.
At 15 active areas x 2 packages = 30 GetLocalInt calls per heartbeat.
GetLocalInt on module object is the cheapest operation in NWScript.
This is effectively zero CPU cost in production.

DEBUG VARIABLE CONSTANTS (core_conductor.nss):
  MG_DEBUG          = "MG_DEBUG"         Master on/off switch
  MG_DEBUG_VERBOSE  = "MG_DEBUG_VERB"    Verbose mode
  MG_DEBUG_REG      = "MG_DEBUG_REG"     Registry operations
  MG_DEBUG_ENC      = "MG_DEBUG_ENC"     Encounter spawning
  MG_DEBUG_GPS      = "MG_DEBUG_GPS"     GPS proximity
  MG_DEBUG_PKG      = "MG_DEBUG_PKG"     Package system
  MG_DEBUG_GRID     = "MG_DEBUG_GRID"    Grid operations
  MG_DEBUG_DISP     = "MG_DEBUG_DISP"    Dispatch / active area registry
  MG_DEBUG_SQL      = "MG_DEBUG_SQL"     SQL operations
  MG_DEBUG_MUD      = "MG_DEBUG_MUD"     MUD chat commands
  MG_DEBUG_AI       = "MG_DEBUG_AI"      AI hub (all sub-systems)
  MG_DEBUG_AI_LOGIC = "MG_DEBUG_AILOG"   AI logic archetype processor
  MG_DEBUG_AI_CAST  = "MG_DEBUG_AICST"   AI caster tactics
  MG_DEBUG_AI_PHYS  = "MG_DEBUG_AIPHY"   AI physics zones
  MG_DEBUG_AI_SURV  = "MG_DEBUG_AISRV"   AI survival (hunger/thirst)
  MG_DEBUG_ADMIN    = "MG_DEBUG_ADMIN"   Admin console operations

--------------------------------------------------------------------------------
  18.6 NEW COLUMNS IN 2DAs
--------------------------------------------------------------------------------

ADDED TO core_package.2da:
  DEBUG_VAR    String name of the module-level int for this package's debug.
               core_switch checks this ONLY when MG_DEBUG is also 1.
               Use **** if this package has no dedicated debug flag.
               Example: "MG_DEBUG_GPS" for the ai_gps package.

  AUTH_LEVEL   Minimum admin ROLE to manually toggle this package via console.
               0=any authenticated admin can toggle it.
               5=builder-only. 10=master-only.
               Does NOT gate normal tick-based dispatch. This is ONLY for
               manual /*pkg on / /*pkg off console commands.

ADDED TO ai_hub.2da:
  AUTH_LEVEL   Same semantics as in core_package.2da, applied to hub sub-systems.

THESE COLUMNS ARE OPTIONAL:
  Older packages without these columns will silently read empty strings / 0.
  No crash, no error. The debug wrapper simply won't fire (sDbgVar will be "").

READING IN CODE:
  PackageBoot() reads and caches as:   PKG_[N]_DBG  and  PKG_[N]_AUTH
  AiHubBoot() reads and caches as:     AI_[N]_DBG   and  AI_[N]_AUTH
  Accessor functions:
    PackageGetDebugVar(nRow)   -> string (e.g. "MG_DEBUG_GPS")
    PackageGetAuthLevel(nRow)  -> int    (e.g. 5)
    AiHubGetDebugVar(nRow)     -> string
    AiHubGetAuthLevel(nRow)    -> int

--------------------------------------------------------------------------------
  18.7 ADDING THE SECURITY SYSTEM TO FUTURE HUBS
--------------------------------------------------------------------------------

Any new hub you create (enc_hub, weather_hub, etc.) should follow the same pattern:

1. Add DEBUG_VAR and AUTH_LEVEL columns to your hub's 2DA.
2. In YourHubBoot(): read both columns, sanitize "****" -> "", cache to module.
3. In YourHubTick(): add the debug wrapper around your dispatch loop:

    if (GetLocalInt(oMod, MG_DEBUG))
    {
        string sDbgVar = GetLocalString(oMod, YOUR_PFX + IntToString(i) + YOUR_DBG_CONST);
        if (sDbgVar != "" && GetLocalInt(oMod, sDbgVar))
        {
            SendMessageToAllDMs("[HUB_DEBUG] subsystem + area + tick");
        }
    }

4. Add your new debug variable name (e.g. MG_DEBUG_ENC_SPAWN) as a const string
   to core_conductor.nss, and add it to AdminSetDebugAll() and AdminSetDebugGroup()
   in core_admin.nss for /*debug all on to include it.

5. To add a console command for your new hub's sub-systems, add an else-if block
   to AdminHandleCommand() in core_admin.nss:

    if (GetStringLeft(sCmd, 12) == "/*hub off " && nRole >= ADM_ROLE_BUILDER)
    {
        // parse sub-system name and disable it the same way packages are disabled
    }

--------------------------------------------------------------------------------
  18.8 QUESTIONS ANSWERED
--------------------------------------------------------------------------------

Q: Does core_heartbeat need to be on Area OnHeartbeat?
A: YES. Wire it to every area's OnHeartbeat event in the toolset. The native area
   heartbeat fires every 6 seconds independently of the module heartbeat. This is
   what makes each area act like a standalone mini-server - the failsafe guarantees
   the area continues ticking even if the module heartbeat stalls. Normal ticking
   flows: Module HB -> core_mhb -> DispatchTick -> core_switch per area.
   Failsafe flows: Area HB -> core_heartbeat -> fires core_switch ONLY IF dispatch
   missed 3+ beats. The two paths are independent.

Q: Do players need the 2DAs? How should I distribute them?
A: Players do NOT need 2DAs. 2DAs are server-side resources read at boot.
   The correct workflow:
   1. Create all your scripts (.nss) and 2DAs on disk.
   2. In the NWN Toolset: File -> Import -> select your ERF or import 2DAs/scripts
      directly. They become part of the .mod file.
   3. Export a fresh ERF from the toolset to share with teammates.
   4. Players connect and play. The .mod file on the server has everything.
   An ERF (Electronic Resource File) is the correct packaging format for scripts
   and 2DAs that you want to import into a module.

Q: Does every sub-system need a JSON?
A: NO. Use JSON only when you need MUTABLE PER-AREA STATE that changes tick to tick.
   Rule of thumb:
   - "What are this NPC's base stats?" -> Module local cache from 2DA. No JSON.
   - "Has this encounter spawned in THIS area THIS session?" -> Area-local JSON. YES.
   - "What is this creature's current hunger level?" -> Creature local variable. No JSON.
   - "Which packages are paused in THIS area right now?" -> core_package's area JSON. YES.
   The ai_hub sub-systems (logic, caster, physics) mostly use creature locals for
   per-NPC state. The hub itself uses a small JSON per area to track which sub-systems
   ran and when (last_tick, run_count, paused flag). That is all that needs JSON at
   hub level.

Q: Would JSON on all 2DAs overload a NWN:EE PW server?
A: Yes, if misused. JSON costs CPU on every read/write cycle. Use it only for:
   - State that changes between ticks IN THE SAME AREA (paused flags, last_tick)
   - State that needs to be compared across multiple packages for the same area
   Static config data (distances, damage values, behavior flags that come from 2DAs)
   should ALWAYS be module locals (read once at boot, O(1) reads thereafter).
   Per-creature state (AI state, hunger, wounds) should be creature locals, not JSON.
   The test: if the data is the same for all areas -> module local.
             if the data differs per area but not per-creature -> area JSON.
             if the data is per-creature -> creature local var.

Q: Should the Race/Class/Caster 2DAs be shared between AI NPCs and player characters?
A: YES, this is an excellent design. The same 2DA can drive both NPC behavior and
   player character mechanics. The script that reads the 2DA accepts a CLASS_ID or
   RACE_ID as input. It doesn't care whether the caller is a PC or NPC.
   For NPCs: ai_class.nss is called by the AI logic sub-system to set combat behavior.
   For PCs: Your player race/class system includes ai_class.nss and calls the same
   functions with the PC's class ID. The 2DA data (HP_DIE, BAB, SPELL_LIST) applies
   equally to both. This is a major advantage of the data-driven design.

Q: Is a SECURITY + DEBUG system like this a good idea for a NWN:EE PW server?
A: It is excellent for a server of this scale. Here is the honest assessment:
   PROS:
   - CD key + password is substantially more secure than password alone
   - Role levels prevent "builder mistakes" from affecting core systems
   - Hot-reload without restart is a professional-grade feature
   - Debug hierarchy (master -> category -> individual) prevents log bloat
   - Zero CPU cost in production (all checks evaluate false in nanoseconds)
   CONS:
   - CD keys can be spoofed with NWNX tools (server-side defense: check IP too)
   - If a team member's machine is compromised, their CD key is exposed
   - The password travels as a chat message - while hidden from players by
     SetPCChatMessage(""), it still goes to the server before being suppressed.
     On a compromised server this could be intercepted.
   MITIGATIONS:
   - Change passwords regularly
   - Use ACTIVE=0 to revoke access immediately when someone leaves
   - The lockdown command gives you an emergency kill switch
   - Log all auth failures with WriteTimestampedLogEntry

================================================================================
  SECTION 19: COMPILE ORDER (Updated with Admin System)
================================================================================

Compile in this exact order. Each file depends on the ones above it.

  1.  core_conductor    (no dependencies)
  2.  core_registry     (#include "core_conductor")
  3.  core_grid         (#include "core_conductor")
  4.  core_package      (#include "core_conductor")
  5.  core_dispatch     (#include "core_conductor")
  6.  core_admin        (#include "core_conductor")
  7.  core_ai_gps       (#include "core_conductor", "core_registry", "core_grid")
  8.  ai_hub            (#include "core_conductor")
  9.  ai_class          (#include "core_conductor")
  10. ai_race           (#include "core_conductor")
  11. ai_logic          (#include "core_conductor")
  12. caster_logic      (#include "core_conductor")
  13. caster_action     (#include "core_conductor")
  14. ai_physics        (#include "core_conductor")
  15. pkg_ai_gps        (#include "core_ai_gps", "core_package")
  16. pkg_ai_hub        (#include "ai_hub", "core_package")
  17. pkg_ai_logic      (includes ai_logic + ai_class + ai_race)
  18. pkg_ai_caster     (includes caster_logic + caster_action)
  19. pkg_ai_physics    (#include "ai_physics", "core_registry")
  20. core_switch       (#include "core_conductor", "core_registry", "core_package", "core_grid")
  21. core_enter        (#include "core_registry", "core_grid", "core_package", "core_conductor")
  22. core_heartbeat    (#include "core_registry", "core_conductor")
  23. core_mhb          (#include "core_dispatch", "core_package")
  24. core_onload       (#include "core_ai_gps", "core_package", "core_dispatch", "core_admin", "ai_hub")
  25. [your MUD script] (#include "core_ai_gps", "core_package", "core_admin", "ai_hub")

NOTE ON MUD SCRIPT: Your OnPlayerChat handler must include enough libraries that
AdminHandleCommand can find all the implementations it calls. See Section 18.3.

================================================================================
  SECTION 20: FILES DELIVERED (Session 3 - Security & Debug System)
================================================================================

NEW FILES:
  core_admin.2da          RBAC authority table (fill in CD keys before going live)

MODIFIED FILES (changes noted):
  core_admin.nss          Full admin library with AdminBoot, AdminGetRole,
                          AdminHandleCommand, debug helpers, all console commands.
                          Already existed from previous session; this is the complete version.
  core_package.2da        Added DEBUG_VAR and AUTH_LEVEL columns.
  core_package.nss        Added PKGC_DBG and PKGC_AUTH constants; PackageBoot reads
                          and caches both columns; added accessor functions.
  core_conductor.nss      Added PackageGetRow, PackageGetDebugVar, PackageGetAuthLevel
                          forward declarations.
  core_switch.nss         Added surgical debug wrapper in Phase 3 dispatch loop.
  ai_hub.2da              Added AUTH_LEVEL column.
  ai_hub.nss              Added AIC_DBG and AIC_AUTH constants; AiHubBoot reads both
                          columns; added AiHubGetDebugVar, AiHubGetAuthLevel accessors;
                          added debug wrapper in AiHubTick dispatch loop.

ALL OTHER FILES UNCHANGED:
  core_registry.nss, core_grid.nss, core_dispatch.nss, core_ai_gps.nss,
  core_enter.nss, core_heartbeat.nss, core_mhb.nss, core_onload.nss,
  core_registry.2da, core_grid.2da, core_ai_gps.2da,
  pkg_ai_gps.nss, pkg_ai_hub.nss, pkg_ai_hub_boot.nss, pkg_ai_hub_shut.nss,
  pkg_ai_hub_lib.nss, pkg_ai_logic.nss, pkg_ai_caster.nss, pkg_ai_physics.nss,
  pkg_ai_survival.nss, ai_class.nss, ai_race.nss, ai_logic.nss,
  caster_logic.nss, caster_action.nss, ai_physics.nss,
  enc_hub.2da, enc_common.2da, enc_uncommon.2da, enc_rare.2da,
  spawn_table_hub.2da

================================================================================
  END OF SESSION 3 ADDITIONS
================================================================================
